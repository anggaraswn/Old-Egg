package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"fmt"
	"time"

	"github.com/anggaraswn/gqlgen-todos/database"
	"github.com/anggaraswn/gqlgen-todos/graph/model"
	"github.com/anggaraswn/gqlgen-todos/service"
	"github.com/google/uuid"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// User is the resolver for the user field.
func (r *cartResolver) User(ctx context.Context, obj *model.Cart) (*model.User, error) {
	// panic(fmt.Errorf("not implemented: User - user"))
	db := database.GetDB()

	user := new(model.User)

	return user, db.First(user, "id = ?", obj.UserID).Error
}

// Product is the resolver for the product field.
func (r *cartResolver) Product(ctx context.Context, obj *model.Cart) (*model.Product, error) {
	// panic(fmt.Errorf("not implemented: Product - product"))
	db := database.GetDB()

	product := new(model.Product)

	return product, db.First(product, "id = ?", obj.ProductID).Error
}

// CreateCart is the resolver for the createCart field.
func (r *mutationResolver) CreateCart(ctx context.Context, input model.NewCart) (*model.Cart, error) {
	db := database.GetDB()
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Invalid Token !",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	cart, _ := service.CartGetByUserProduct(ctx, userID, input.ProductID)

	var product model.Product
	if err := db.Where("id = ?", input.ProductID).Limit(1).Find(&product).Error; err != nil {
		return nil, err
	}

	if input.Quantity > product.Stock {
		println(product.Stock)
		return nil, &gqlerror.Error{
			Message: "Invalid Purchased Product Stock!",
		}
	}
	if cart != nil {
		println(cart.Quantity)
		if cart.Quantity+input.Quantity > product.Stock {
			return nil, &gqlerror.Error{
				Message: "Invalid Purchased Product Stock!",
			}
		}
		cart.Quantity = cart.Quantity + input.Quantity
		cart.Notes = input.Notes

		return cart, db.Save(cart).Error
	}

	saveForLater := new(model.SaveForLater)
	if err := db.Where("user_id = ? AND product_id = ?", userID, product.ID).Limit(1).Find(&saveForLater).Error; err != nil {
		return nil, &gqlerror.Error{
			Message: "Invalid Save For Later!",
		}
	}

	if saveForLater != nil {
		db.Exec("DELETE FROM save_for_laters WHERE user_id = ? AND product_id = ?", userID, input.ProductID)
	}

	return service.CartCreate(ctx, userID, input.ProductID, input.Quantity, input.Notes)
}

// UpdateCart is the resolver for the updateCart field.
func (r *mutationResolver) UpdateCart(ctx context.Context, input model.NewCart, deliveryID *string) (*model.Cart, error) {
	// panic(fmt.Errorf("not implemented: UpdateCart - updateCart"))
	db := database.GetDB()
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Invalid Token !",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	var cart model.Cart
	if err := db.Model(cart).Where("product_id = ?", input.ProductID).Take(&cart).Error; err != nil {
		return nil, err
	}

	cart.UserID = userID
	cart.ProductID = input.ProductID
	cart.Quantity = input.Quantity
	cart.Notes = input.Notes

	return &cart, db.Save(cart).Error
}

// DeleteCart is the resolver for the deleteCart field.
func (r *mutationResolver) DeleteCart(ctx context.Context, productID string) (*model.Cart, error) {
	// panic(fmt.Errorf("not implemented: DeleteCart - deleteCart"))
	db := database.GetDB()
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Invalid Token !",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	cart := new(model.Cart)
	if err := db.Where("user_id = ? AND product_id = ?", userID, productID).Take(&cart).Error; err != nil {
		return nil, err
	}

	return cart, db.Exec("DELETE FROM carts WHERE user_id = ? AND product_id = ?", userID, productID).Error
}

// CreateWishlist is the resolver for the createWishlist field.
func (r *mutationResolver) CreateWishlist(ctx context.Context, name string, option model.Option) (*model.Wishlist, error) {
	// panic(fmt.Errorf("not implemented: CreateWishlist - createWishlist"))
	db := database.GetDB()
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Invalid Token !",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	wishlist := model.Wishlist{
		ID:          uuid.NewString(),
		Name:        name,
		UserID:      userID,
		Option:      option,
		CreatedDate: time.Now(),
	}

	if err := db.Model(wishlist).Create(&wishlist).Error; err != nil {
		return nil, err
	}

	return &wishlist, nil
}

// UpdateWishlist is the resolver for the updateWishlist field.
func (r *mutationResolver) UpdateWishlist(ctx context.Context, wishlistID string, name *string, option *string, notes *string) (*model.Wishlist, error) {
	// panic(fmt.Errorf("not implemented: UpdateWishlist - updateWishlist"))
	db := database.GetDB()
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Invalid Token !",
		}
	}

	var wishlist model.Wishlist
	if err := db.Model(wishlist).Where("id = ?", wishlistID).Take(&wishlist).Error; err != nil {
		return nil, err
	}

	if name != nil {
		wishlist.Name = *name
	}

	if option != nil {
		wishlist.Option = model.Option(*option)
	}
	if notes != nil {
		wishlist.Notes = *notes
	}

	return &wishlist, db.Save(wishlist).Error
}

// DeleteWishlist is the resolver for the deleteWishlist field.
func (r *mutationResolver) DeleteWishlist(ctx context.Context, wishlistID string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteWishlist - deleteWishlist"))
}

// CreateWishlistDetail is the resolver for the createWishlistDetail field.
func (r *mutationResolver) CreateWishlistDetail(ctx context.Context, wishlistID string, productID string, quantity *int) (*model.WishListDetail, error) {
	// panic(fmt.Errorf("not implemented: CreateWishlistDetail - createWishlistDetail"))
	db := database.GetDB()

	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Invalid Token !",
		}
	}

	// userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	wishlist := &model.WishListDetail{
		WishlistID: wishlistID,
		ProductID:  productID,
	}

	if quantity != nil {
		wishlist.Quantity = *quantity
	} else {
		wishlist.Quantity = 1
	}

	return wishlist, db.Model(wishlist).Create(&wishlist).Error
}

// UpdateWishlistDetail is the resolver for the updateWishlistDetail field.
func (r *mutationResolver) UpdateWishlistDetail(ctx context.Context, wishlistID *string, productID string, quantity *int) (*model.WishListDetail, error) {
	// panic(fmt.Errorf("not implemented: UpdateWishlistDetail - updateWishlistDetail"))
	db := database.GetDB()
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Invalid Token !",
		}
	}

	wishlistDetail := new(model.WishListDetail)

	if err := db.Where("wishlist_id = ? AND product_id = ?", wishlistID, productID).Take(&wishlistDetail).Error; err != nil {
		return nil, err
	}

	product := new(model.Product)

	if err := db.Where("id = ?", productID).Take(&product).Error; err != nil {
		return nil, err
	}

	var err error
	if quantity != nil {
		if *quantity <= product.Stock && *quantity > 0 {
			err = db.Exec("UPDATE wish_list_details SET quantity = ? WHERE product_id = ? AND wishlist_id = ?", quantity, productID, wishlistID).Error
		} else {
			err = &gqlerror.Error{
				Message: "Quantity not valid",
			}
		}
	} else {
		err = &gqlerror.Error{
			Message: "Tidak ada quantity",
		}
	}

	return wishlistDetail, err
}

// DeleteWishlistDetail is the resolver for the deleteWishlistDetail field.
func (r *mutationResolver) DeleteWishlistDetail(ctx context.Context, wishlistID string, productID string) (*model.WishListDetail, error) {
	// panic(fmt.Errorf("not implemented: DeleteWishlistDetail - deleteWishlistDetail"))
	db := database.GetDB()
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Invalid Token !",
		}
	}

	wishlistDetail := new(model.WishListDetail)
	if err := db.First(wishlistDetail, "wishlist_id = ? AND product_id = ?", wishlistID, productID).Error; err != nil {
		return nil, err
	}

	// return wishlistDetail, db.Delete(wishlistDetail).Error
	return wishlistDetail, db.Exec("DELETE FROM wish_list_details WHERE wishlist_id = ? AND product_id = ?", wishlistID, productID).Error
}

// CreateSaveForLater is the resolver for the createSaveForLater field.
func (r *mutationResolver) CreateSaveForLater(ctx context.Context, productID string, quantity int) (*model.SaveForLater, error) {
	// panic(fmt.Errorf("not implemented: CreateSaveForLater - createSaveForLater"))
	db := database.GetDB()
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Invalid Token !",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	println(productID)
	product := new(model.Product)

	// var product model.Product
	if err := db.Where("id = ?", productID).Limit(1).Find(&product).Error; err != nil {
		return nil, &gqlerror.Error{
			Message: "Invalid Product!",
		}
	}

	if quantity < 1 {
		return nil, &gqlerror.Error{
			Message: "Invalid Quantity !",
		}
	}

	saveForLater, _ := service.SaveForLaterGetByUserProduct(ctx, userID, productID)

	println(product.Stock)
	// saveForLater := new(model.SaveForLater)

	// if(quantity > product.Stock){
	// 	return nil, &gqlerror.Error{
	// 		Message: "Invalid Quantity!",
	// 	}
	// }

	if saveForLater != nil {
		println(saveForLater.Quantity)
		if (saveForLater.Quantity + quantity) > product.Stock {
			return nil, &gqlerror.Error{
				Message: "Invalid Quantity !",
			}
		}

		return saveForLater, db.Exec("UPDATE save_for_laters SET quantity = ? WHERE user_id = ? AND product_id = ?", (saveForLater.Quantity + quantity), userID, productID).Error
	}

	saveForLater = &model.SaveForLater{}
	saveForLater.ProductID = productID
	saveForLater.UserID = userID
	saveForLater.Quantity = quantity

	cart := new(model.Cart)
	if err := db.Where("user_id = ? AND product_id = ?", userID, productID).Limit(1).Find(&cart).Error; err != nil {
		return nil, &gqlerror.Error{
			Message: "Invalid Cart!",
		}
	}

	println(cart.UserID)
	if cart != nil {
		db.Exec("DELETE FROM carts WHERE user_id = ? AND product_id = ?", cart.UserID, cart.ProductID)
	}

	return saveForLater, db.Model(saveForLater).Create(&saveForLater).Error
}

// DeleteSaveForLater is the resolver for the deleteSaveForLater field.
func (r *mutationResolver) DeleteSaveForLater(ctx context.Context, productID string) (*model.Product, error) {
	// panic(fmt.Errorf("not implemented: DeleteSaveForLater - deleteSaveForLater"))
	db := database.GetDB()
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Invalid Token !",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	saveForLater := new(model.SaveForLater)

	if err := db.Where("user_id = ? AND product_id = ?", userID, productID).Take(&saveForLater).Error; err != nil {
		return nil, err
	}

	return saveForLater.Product, db.Exec("DELETE FROM save_for_laters WHERE user_id = ? AND product_id = ?", userID, productID).Error
}

// FollowWishlist is the resolver for the followWishlist field.
func (r *mutationResolver) FollowWishlist(ctx context.Context, wishlistID string) (*model.WishlistFollower, error) {
	// panic(fmt.Errorf("not implemented: FollowWishlist - followWishlist"))
	db := database.GetDB()
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Invalid Token !",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	follow := model.WishlistFollower{
		WishlistID: wishlistID,
		UserID:     userID,
	}

	return &follow, db.Create(follow).Error
}

// UnfollowWishlist is the resolver for the unfollowWishlist field.
func (r *mutationResolver) UnfollowWishlist(ctx context.Context, wishlistID string) (*model.WishlistFollower, error) {
	// panic(fmt.Errorf("not implemented: UnfollowWishlist - unfollowWishlist"))
	db := database.GetDB()
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Invalid Token !",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	follow := new(model.WishlistFollower)
	if err := db.Where("user_id = ? AND wishlist_id = ?", userID, wishlistID).Take(&follow).Error; err != nil {
		return nil, err
	}

	return follow, db.Exec("DELETE FROM wishlist_followers WHERE user_id = ? AND wishlist_id = ?", userID, wishlistID).Error
}

// Carts is the resolver for the carts field.
func (r *queryResolver) Carts(ctx context.Context) ([]*model.Cart, error) {
	// panic(fmt.Errorf("not implemented: Carts - carts"))
	db := database.GetDB()
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Invalid Token !",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID
	var carts []*model.Cart

	return carts, db.Where("user_id = ?", userID).Find(&carts).Error
}

// Cart is the resolver for the cart field.
func (r *queryResolver) Cart(ctx context.Context, productID string) (*model.Cart, error) {
	panic(fmt.Errorf("not implemented: Cart - cart"))
}

// CurrentUserWishlist is the resolver for the currentUserWishlist field.
func (r *queryResolver) CurrentUserWishlist(ctx context.Context) ([]*model.Wishlist, error) {
	// panic(fmt.Errorf("not implemented: CurrentUserWishlist - currentUserWishlist"))
	db := database.GetDB()

	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Invalid Token !",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	var wishlists []*model.Wishlist

	return wishlists, db.Where("user_id = ?", userID).Find(&wishlists).Error
}

// Wishlists is the resolver for the wishlists field.
func (r *queryResolver) Wishlists(ctx context.Context, filter *string, sortBy *string, limit *int, offset *int) ([]*model.Wishlist, error) {
	// panic(fmt.Errorf("not implemented: Wishlists - wishlists"))
	db := database.GetDB()

	var wishlists []*model.Wishlist
	temp := db.Model(wishlists)

	if filter != nil {
		temp = temp.Where("option LIKE ?", filter)
	}

	if sortBy != nil {
		if *sortBy == "createdDate" {
			println("Created Date")
			temp = temp.Order("created_date DESC")
		} else if *sortBy == "highestRating" {
			println("Highest Rating")
			temp = temp.Select("wishlists.id, wishlists.name, wishlists.user_id, wishlists.option, wishlists.created_date, wishlists.notes").Joins("LEFT JOIN wishlist_reviews ON wishlists.id = wishlist_reviews.wishlist_id").Group("wishlists.id").Order("COUNT(wishlist_reviews.id) DESC, AVG(wishlist_reviews.rating) DESC")
		} else if *sortBy == "lowestRating" {
			temp = temp.Select("wishlists.id, wishlists.name, wishlists.user_id, wishlists.option, wishlists.created_date, wishlists.notes").Joins("LEFT JOIN wishlist_reviews ON wishlists.id = wishlist_reviews.wishlist_id").Group("wishlists.id").Order("COUNT(wishlist_reviews.id) DESC, AVG(wishlist_reviews.rating) ASC")
		} else if *sortBy == "highestPrice" {
			temp = temp.Select("wishlists.id, wishlists.name, wishlists.user_id, wishlists.option, wishlists.created_date, wishlists.notes ").Joins("LEFT JOIN wishlist_details ON wishlists.id = wishlist_details.wishlist_id JOIN products  ON wishlist_details.product_id = products.id").Group("wishlists.id").Order("SUM(products.price) DESC")
		} else if *sortBy == "lowestPrice" {
			temp = temp.Select("wishlists.id, wishlists.name, wishlists.user_id, wishlists.option, wishlists.created_date, wishlists.notes ").Joins("LEFT JOIN wishlist_details ON wishlists.id = wishlist_details.wishlist_id JOIN products  ON wishlist_details.product_id = products.id").Group("wishlists.id").Order("SUM(products.price) ASC")
		} else if *sortBy == "highestFollowers" {
			temp = temp.Select("wishlists.id, wishlists.name, wishlists.user_id, wishlists.option, wishlists.created_date, wishlists.notes").Joins("LEFT JOIN wishlist_followers ON wishlists.id = wishlist_followers.wishlist_id").Group("wishlists.id").Order("COUNT(wishlist_followers.wishlist_id) DESC")
		}

	}

	if offset != nil {
		temp = temp.Offset(*offset)
	}

	if limit != nil {
		temp = temp.Limit(*limit)
	}

	return wishlists, temp.Find(&wishlists).Error
}

// Wishlist is the resolver for the wishlist field.
func (r *queryResolver) Wishlist(ctx context.Context, wishlistID string) (*model.Wishlist, error) {
	// panic(fmt.Errorf("not implemented: Wishlist - wishlist"))
	db := database.GetDB()

	wishlist := new(model.Wishlist)

	return wishlist, db.First(wishlist, "id = ?", wishlistID).Error
}

// SaveForLaters is the resolver for the saveForLaters field.
func (r *queryResolver) SaveForLaters(ctx context.Context) ([]*model.SaveForLater, error) {
	// panic(fmt.Errorf("not implemented: SaveForLaters - saveForLaters"))
	db := database.GetDB()
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Invalid Token !",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	var saveForLaters []*model.SaveForLater

	return saveForLaters, db.Where("user_id = ?", userID).Find(&saveForLaters).Error
}

// WishlistDetails is the resolver for the wishlistDetails field.
func (r *queryResolver) WishlistDetails(ctx context.Context, wishlistID string) ([]*model.WishListDetail, error) {
	// panic(fmt.Errorf("not implemented: WishlistDetails - wishlistDetails"))
	db := database.GetDB()

	var models []*model.WishListDetail
	return models, db.Where("wishlist_id = ?", wishlistID).Find(&models).Error
}

// WishlistFollower is the resolver for the wishlistFollower field.
func (r *queryResolver) WishlistFollower(ctx context.Context, wishlistID string) (*model.WishlistFollower, error) {
	// panic(fmt.Errorf("not implemented: WishlistFollower - wishlistFollower"))
	db := database.GetDB()
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Invalid Token !",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	follow := new(model.WishlistFollower)

	return follow, db.Where("user_id = ?", userID).Find(&follow).Error
}

// WishlistFollowers is the resolver for the wishlistFollowers field.
func (r *queryResolver) WishlistFollowers(ctx context.Context, wishlistID string) ([]*model.WishlistFollower, error) {
	// panic(fmt.Errorf("not implemented: WishlistFollowers - wishlistFollowers"))
	db := database.GetDB()
	var followers []*model.WishlistFollower

	return followers, db.Where("wishlist_id = ?", wishlistID).Find(&followers).Error
}

// UserFollowedWishlists is the resolver for the userFollowedWishlists field.
func (r *queryResolver) UserFollowedWishlists(ctx context.Context) ([]*model.WishlistFollower, error) {
	// panic(fmt.Errorf("not implemented: UserFollowedWishlists - userFollowedWishlists"))
	db := database.GetDB()
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Invalid Token !",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	var followed []*model.WishlistFollower

	return followed, db.Where("user_id = ?", userID).Find(&followed).Error
}

// User is the resolver for the user field.
func (r *saveForLaterResolver) User(ctx context.Context, obj *model.SaveForLater) (*model.User, error) {
	// panic(fmt.Errorf("not implemented: User - user"))
	db := database.GetDB()

	user := new(model.User)

	return user, db.Where("id = ?", obj.UserID).Take(&user).Error
}

// Product is the resolver for the product field.
func (r *saveForLaterResolver) Product(ctx context.Context, obj *model.SaveForLater) (*model.Product, error) {
	// panic(fmt.Errorf("not implemented: Product - product"))
	db := database.GetDB()

	product := new(model.Product)

	return product, db.Where("id = ?", obj.ProductID).Take(&product).Error
}

// Wishlist is the resolver for the wishlist field.
func (r *wishListDetailResolver) Wishlist(ctx context.Context, obj *model.WishListDetail) (*model.Wishlist, error) {
	// panic(fmt.Errorf("not implemented: Wishlist - wishlist"))
	db := database.GetDB()

	wishlist := new(model.Wishlist)

	return wishlist, db.Where("id = ?", obj.WishlistID).Take(&wishlist).Error
}

// Product is the resolver for the product field.
func (r *wishListDetailResolver) Product(ctx context.Context, obj *model.WishListDetail) (*model.Product, error) {
	// panic(fmt.Errorf("not implemented: Product - product"))
	db := database.GetDB()

	product := new(model.Product)

	return product, db.Where("id = ?", obj.ProductID).Take(&product).Error
}

// User is the resolver for the user field.
func (r *wishlistResolver) User(ctx context.Context, obj *model.Wishlist) (*model.User, error) {
	// panic(fmt.Errorf("not implemented: User - user"))
	db := database.GetDB()

	user := new(model.User)

	return user, db.Where("id = ?", obj.UserID).Take(&user).Error
}

// WishlistDetails is the resolver for the wishlistDetails field.
func (r *wishlistResolver) WishlistDetails(ctx context.Context, obj *model.Wishlist) ([]*model.WishListDetail, error) {
	// panic(fmt.Errorf("not implemented: WishlistDetails - wishlistDetails"))
	db := database.GetDB()

	var models []*model.WishListDetail
	return models, db.Where("wishlist_id = ?", obj.ID).Find(&models).Error
}

// Wishlist is the resolver for the wishlist field.
func (r *wishlistFollowerResolver) Wishlist(ctx context.Context, obj *model.WishlistFollower) (*model.Wishlist, error) {
	// panic(fmt.Errorf("not implemented: Wishlist - wishlist"))
	db := database.GetDB()

	wishlist := new(model.Wishlist)

	return wishlist, db.Where("id = ?", obj.WishlistID).Find(&wishlist).Error
}

// User is the resolver for the user field.
func (r *wishlistFollowerResolver) User(ctx context.Context, obj *model.WishlistFollower) (*model.User, error) {
	// panic(fmt.Errorf("not implemented: User - user"))
	db := database.GetDB()

	user := new(model.User)

	return user, db.Where("id = ?", obj.UserID).Find(&user).Error
}

// Cart returns CartResolver implementation.
func (r *Resolver) Cart() CartResolver { return &cartResolver{r} }

// SaveForLater returns SaveForLaterResolver implementation.
func (r *Resolver) SaveForLater() SaveForLaterResolver { return &saveForLaterResolver{r} }

// WishListDetail returns WishListDetailResolver implementation.
func (r *Resolver) WishListDetail() WishListDetailResolver { return &wishListDetailResolver{r} }

// Wishlist returns WishlistResolver implementation.
func (r *Resolver) Wishlist() WishlistResolver { return &wishlistResolver{r} }

// WishlistFollower returns WishlistFollowerResolver implementation.
func (r *Resolver) WishlistFollower() WishlistFollowerResolver { return &wishlistFollowerResolver{r} }

type cartResolver struct{ *Resolver }
type saveForLaterResolver struct{ *Resolver }
type wishListDetailResolver struct{ *Resolver }
type wishlistResolver struct{ *Resolver }
type wishlistFollowerResolver struct{ *Resolver }
